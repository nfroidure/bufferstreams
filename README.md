[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# bufferstreams
> Abstract streams to deal with the whole buffered contents.

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nfroidure/bufferstreams/blob/main/LICENSE)
[![Coverage Status](https://coveralls.io/repos/github/git://github.com/nfroidure/BufferStreams/badge.svg?branch=main)](https://coveralls.io/github/git://github.com/nfroidure/BufferStreams?branch=main)


[//]: # (::contents:start)

`bufferstreams` abstracts streams to allow you to deal with their whole content
in a single buffer when it becomes necessary (by example: a legacy library that
do not support streams).

It is not a good practice (dealing with the whole stream content means you need
to keep the whole stream content in memory which is probably not what you intent
by using streams), just some glue. Using `bufferstreams` means:

- there is no library dealing with streams for your needs
- you filled an issue to the wrapped library to support streams

`bufferstreams` can also be used to control the whole stream content in a single
point of a streaming pipeline for testing purposes.

## Usage

Install the [npm module](https://npmjs.org/package/bufferstreams):

```sh
npm install bufferstreams --save
```

Then, in your scripts:

```js
import fs from 'fs';
import { BufferStream } from 'bufferstreams';

fs.createReadStream('input.txt')
  .pipe(
    new BufferStream((err, buf, cb) => {
      // err will be filled with an error if the piped in stream emits one.
      if (err) {
        throw err;
      }

      // buf will contain the whole piped in stream contents
      buf = Buffer.from(buf.toString('utf-8').replace('foo', 'bar'));

      // cb is a callback to pass the result back to the piped out stream
      // first argument is an error that will be emitted if any
      // the second argument is the modified buffer
      cb(null, buf);
    }),
  )
  .pipe(fs.createWriteStream('output.txt'));
```

Note that you can use `bufferstreams` with the objectMode option. In this case,
the given buffer will be an array containing the streamed objects:

```js
new BufferStreams(myCallback, { objectMode: true });
```

`bufferstreams` exposes a utility function for functional programming:

```js
import { streamBuffer } from 'bufferstreams';

process.stdin.pipe(streamBuffer(myCallback)).pipe(process.stdout);
```

Finally `bufferstreams` exposes another function for objects mode buffering:

```js
import { bufferObjects } from 'bufferstreams';

process.stdin.pipe(bufferObjects(myCallback)).pipe(process.stdout);
```

## Contributing

Feel free to contribute with your code if you agree with publishing it under the
MIT license.

[//]: # (::contents:end)

# API
## Classes

<dl>
<dt><a href="#BufferStream">BufferStream</a></dt>
<dd><p>Buffer the stream content and bring it into the provided callback</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bufferStream">bufferStream(bufferCallback, options)</a> ⇒</dt>
<dd><p>Utility function if you prefer a functional way of using this lib</p>
</dd>
<dt><a href="#bufferObjects">bufferObjects(bufferCallback, options)</a> ⇒</dt>
<dd><p>Utility function to buffer objet mode streams</p>
</dd>
</dl>

<a name="BufferStream"></a>

## BufferStream
Buffer the stream content and bring it into the provided callback

**Kind**: global class  
<a name="new_BufferStream_new"></a>

### new BufferStream(bufferCallback, options)

| Param | Type | Description |
| --- | --- | --- |
| bufferCallback | <code>function</code> | A function to handle the buffered content. |
| options | <code>Object</code> | inherits of Stream.Duplex, the options are passed to the parent constructor so you can use it's options too. |
| options.objectMode | <code>boolean</code> | Use if piped in streams are in object mode. In this case, an array of the buffered will be transmitted to the callback function. |

<a name="bufferStream"></a>

## bufferStream(bufferCallback, options) ⇒
Utility function if you prefer a functional way of using this lib

**Kind**: global function  
**Returns**: Stream  

| Param |
| --- |
| bufferCallback | 
| options | 

<a name="bufferObjects"></a>

## bufferObjects(bufferCallback, options) ⇒
Utility function to buffer objet mode streams

**Kind**: global function  
**Returns**: Stream  

| Param |
| --- |
| bufferCallback | 
| options | 


# Authors
- [Nicolas Froidure](http://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/bufferstreams/blob/main/LICENSE)
